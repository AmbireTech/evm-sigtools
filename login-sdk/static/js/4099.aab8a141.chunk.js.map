{"version":3,"file":"static/js/4099.aab8a141.chunk.js","mappings":"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","sources":["../node_modules/eccrypto/browser.js","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/eth-crypto/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/eth-crypto/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/create-identity.js","../node_modules/eth-crypto/dist/es/util.js","../node_modules/eth-crypto/dist/es/public-key.js","../node_modules/eth-crypto/dist/es/cipher.js","../node_modules/eth-crypto/dist/es/decrypt-with-private-key.js","../node_modules/eth-crypto/dist/es/encrypt-with-public-key.js","../node_modules/eth-crypto/dist/es/public-key-by-private-key.js","../node_modules/eth-crypto/dist/es/recover-public-key.js","../node_modules/eth-crypto/dist/es/recover.js","../node_modules/eth-crypto/dist/es/sign.js","../node_modules/eth-crypto/dist/es/sign-transaction.js","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/tx-data-by-compiled.js","../node_modules/eth-crypto/dist/es/calculate-contract-address.js","../node_modules/eth-crypto/dist/es/hash.js","../node_modules/eth-crypto/dist/es/hex.js","../node_modules/eth-crypto/dist/es/vrs.js","../node_modules/eth-crypto/dist/es/index.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.6.0\";\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.6.0\";\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.6.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        logger.checkNew(new.target, Wallet);\n\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const version = \"wallet/5.6.0\";\n","import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","export function removeLeading0x(str) {\n  if (str.startsWith('0x')) return str.substring(2);else return str;\n}\nexport function addLeading0x(str) {\n  if (!str.startsWith('0x')) return '0x' + str;else return str;\n}\nexport function uint8ArrayToHex(arr) {\n  return Buffer.from(arr).toString('hex');\n}\nexport function hexToUnit8Array(str) {\n  return new Uint8Array(Buffer.from(str, 'hex'));\n}","import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false)); // remove trailing 04\n\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\n\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher; // use compressed key because it's smaller\n\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'), // 16bit\n  Buffer.from(compressedKey, 'hex'), // 33bit\n  Buffer.from(cipher.mac, 'hex'), // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  }; // decompress publicKey\n\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","import { decrypt } from 'eccrypto';\nimport { parse } from './cipher';\nimport { removeLeading0x } from './util';\nexport default function decryptWithPrivateKey(privateKey, encrypted) {\n  encrypted = parse(encrypted); // remove trailing '0x' from privateKey\n\n  var twoStripped = removeLeading0x(privateKey);\n  var encryptedBuffer = {\n    iv: Buffer.from(encrypted.iv, 'hex'),\n    ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, 'hex'),\n    ciphertext: Buffer.from(encrypted.ciphertext, 'hex'),\n    mac: Buffer.from(encrypted.mac, 'hex')\n  };\n  return decrypt(Buffer.from(twoStripped, 'hex'), encryptedBuffer).then(function (decryptedBuffer) {\n    return decryptedBuffer.toString();\n  });\n}","import { encrypt } from 'eccrypto';\nimport { decompress } from './public-key';\nexport default function encryptWithPublicKey(publicKey, message, opts) {\n  // ensure its an uncompressed publicKey\n  publicKey = decompress(publicKey); // re-add the compression-flag\n\n  var pubString = '04' + publicKey;\n  return encrypt(Buffer.from(pubString, 'hex'), Buffer.from(message), opts ? opts : {}).then(function (encryptedBuffers) {\n    var encrypted = {\n      iv: encryptedBuffers.iv.toString('hex'),\n      ephemPublicKey: encryptedBuffers.ephemPublicKey.toString('hex'),\n      ciphertext: encryptedBuffers.ciphertext.toString('hex'),\n      mac: encryptedBuffers.mac.toString('hex')\n    };\n    return encrypted;\n  });\n}","import { privateToPublic, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\n/**\n * Generate publicKey from the privateKey.\n * This creates the uncompressed publicKey,\n * where 04 has stripped from left\n * @returns {string}\n */\n\nexport default function publicKeyOfPrivateKey(privateKey) {\n  privateKey = addLeading0x(privateKey);\n  var publicKeyBuffer = privateToPublic(toBuffer(privateKey));\n  return publicKeyBuffer.toString('hex');\n}","import { ecdsaRecover } from 'secp256k1';\nimport { removeLeading0x, hexToUnit8Array, uint8ArrayToHex } from './util';\n/**\n * returns the publicKey for the privateKey with which the messageHash was signed\n * @param  {string} signature\n * @param  {string} hash\n * @return {string} publicKey\n */\n\nexport default function recoverPublicKey(signature, hash) {\n  signature = removeLeading0x(signature); // split into v-value and sig\n\n  var sigOnly = signature.substring(0, signature.length - 2); // all but last 2 chars\n\n  var vValue = signature.slice(-2); // last 2 chars\n\n  var recoveryNumber = vValue === '1c' ? 1 : 0;\n  var pubKey = uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(sigOnly), recoveryNumber, hexToUnit8Array(removeLeading0x(hash)), false)); // remove trailing '04'\n\n  pubKey = pubKey.slice(2);\n  return pubKey;\n}","import recoverPublicKey from './recover-public-key';\nimport { toAddress as addressByPublicKey } from './public-key';\n/**\n * returns the adress with which the messageHash was signed\n * @param  {string} sigString\n * @param  {string} hash\n * @return {string} address\n */\n\nexport default function recover(sigString, hash) {\n  var pubkey = recoverPublicKey(sigString, hash);\n  var address = addressByPublicKey(pubkey);\n  return address;\n}","import { ecdsaSign as secp256k1_sign } from 'secp256k1';\nimport { addLeading0x, removeLeading0x } from './util';\n/**\n * signs the given message\n * we do not use sign from eth-lib because the pure secp256k1-version is 90% faster\n * @param  {string} privateKey\n * @param  {string} hash\n * @return {string} hexString\n */\n\nexport default function sign(privateKey, hash) {\n  hash = addLeading0x(hash);\n  if (hash.length !== 66) throw new Error('EthCrypto.sign(): Can only sign hashes, given: ' + hash);\n  var sigObj = secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(hash), 'hex')), new Uint8Array(Buffer.from(removeLeading0x(privateKey), 'hex')));\n  var recoveryId = sigObj.recid === 1 ? '1c' : '1b';\n  var newSignature = '0x' + Buffer.from(sigObj.signature).toString('hex') + recoveryId;\n  return newSignature;\n}","import { Transaction } from '@ethereumjs/tx';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport { toAddress as addressByPublicKey } from './public-key';\nexport default function signTransaction(rawTx, privateKey) {\n  var txOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // check if privateKey->address matches rawTx.from\n  var publicKey = publicKeyByPrivateKey(privateKey);\n  var address = addressByPublicKey(publicKey);\n  if (address != rawTx.from) throw new Error('EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey');\n  var privateKeyBuffer = Buffer.from(privateKey.replace(/^.{2}/g, ''), 'hex');\n  var tx = Transaction.fromTxData(rawTx, txOptions);\n  var signedTx = tx.sign(privateKeyBuffer);\n  var serializedTx = signedTx.serialize().toString('hex');\n  return serializedTx;\n}","export const version = \"abi/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        logger.checkNew(new.target, Contract);\n\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"contracts/5.6.0\";\n","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { ContractFactory } from 'ethers';\nexport default function txDataByCompiled(abi, bytecode, args) {\n  // solc returns a string which is often passed instead of the json\n  if (typeof abi === 'string') abi = JSON.parse(abi); // Construct a Contract Factory\n\n  var factory = new ContractFactory(abi, '0x' + bytecode);\n  var deployTransaction = factory.getDeployTransaction.apply(factory, _toConsumableArray(args));\n  return deployTransaction.data;\n}","import { generateAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\nexport default function calculateContractAddress(creatorAddress, nonce) {\n  var addressBuffer = generateAddress(toBuffer(addLeading0x(creatorAddress)), toBuffer(nonce));\n  var address = addressBuffer.toString('hex');\n  return toChecksumAddress(addLeading0x(address));\n}","import { utils as ethersUtils } from 'ethers';\nexport function keccak256(params) {\n  var types = [];\n  var values = [];\n\n  if (!Array.isArray(params)) {\n    types.push('string');\n    values.push(params);\n  } else {\n    params.forEach(function (p) {\n      types.push(p.type);\n      values.push(p.value);\n    });\n  }\n\n  return ethersUtils.solidityKeccak256(types, values);\n}\nexport var SIGN_PREFIX = '\\x19Ethereum Signed Message:\\n32';","/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex); // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n\n  var hex = '';\n\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","import { utils as ethersUtils } from 'ethers';\n/**\n * split signature-hex into parts\n * @param  {string} hexString\n * @return {{v: string, r: string, s: string}}\n */\n\nexport function fromString(hexString) {\n  var arr = ethersUtils.splitSignature(hexString);\n  return {\n    // convert \"v\" to hex\n    v: \"0x\".concat(arr.v.toString(16)),\n    r: arr.r,\n    s: arr.s\n  };\n}\n/**\n * merge signature-parts to one string\n * @param  {{v: string, r: string, s: string}} sig\n * @return {string} hexString\n */\n\nexport function toString(sig) {\n  return ethersUtils.joinSignature(sig);\n}","import createIdentity from './create-identity';\nimport * as publicKey from './public-key';\nimport decryptWithPrivateKey from './decrypt-with-private-key';\nimport encryptWithPublicKey from './encrypt-with-public-key';\nimport * as cipher from './cipher';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport recover from './recover';\nimport recoverPublicKey from './recover-public-key';\nimport sign from './sign';\nimport signTransaction from './sign-transaction';\nimport txDataByCompiled from './tx-data-by-compiled';\nimport calculateContractAddress from './calculate-contract-address';\nimport * as hash from './hash';\nimport * as hex from './hex';\nimport * as vrs from './vrs';\nimport * as util from './util';\nexport { createIdentity, publicKey, decryptWithPrivateKey, encryptWithPublicKey, cipher, publicKeyByPrivateKey, recover, recoverPublicKey, sign, signTransaction, txDataByCompiled, calculateContractAddress, hash, hex, vrs, util };\nexport default {\n  createIdentity: createIdentity,\n  publicKey: publicKey,\n  decryptWithPrivateKey: decryptWithPrivateKey,\n  encryptWithPublicKey: encryptWithPublicKey,\n  cipher: cipher,\n  publicKeyByPrivateKey: publicKeyByPrivateKey,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  sign: sign,\n  signTransaction: signTransaction,\n  txDataByCompiled: txDataByCompiled,\n  calculateContractAddress: calculateContractAddress,\n  hash: hash,\n  hex: hex,\n  vrs: vrs,\n  util: util\n};"],"names":["ec","EC","require","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isValidPrivateKey","privateKey","x","isBuffer","length","compare","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","result","createHash","update","digest","getAes","op","iv","key","data","importKey","name","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","getPublic","keyFromPrivate","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","exports","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","hash","encryptionKey","slice","dataToMac","hmac","createHmac","hmacSha256Sign","mac","sig","b1","b2","res","i","equalConstTime","macGood","logger","Logger","allowedTransactionKeys","forwardErrors","Signer","checkAbstract","defineReadOnly","this","blockTag","_checkProvider","provider","getBalance","getAddress","getTransactionCount","transaction","resolveProperties","checkTransaction","tx","estimateGas","call","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getGasPrice","getFeeData","resolveName","indexOf","throwArgumentError","shallowCopy","all","toLowerCase","to","__awaiter","address","catch","error","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","type","feeData","throwError","operation","nonce","gasLimit","code","getChainId","results","value","_isSigner","VoidSigner","checkNew","_fail","domain","types","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","hex","_hex","_isBigNumber","Object","freeze","toBigNumber","toBN","fromTwos","toTwos","substring","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","toString","BigInt","e","arguments","warn","toHexString","match","toHex","String","anyValue","isBytes","hexlify","isHexString","fault","params","val","equal","l","r","utils","zero2","word","enc","Array","isArray","replace","push","parseInt","c","charCodeAt","hi","lo","encode","minAssert","minUtils","getNAF","num","w","bits","naf","Math","max","bitLength","fill","ws","k","clone","z","mod","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","prototype","undefined","parseBytes","bytes","intFromLE","BaseCurve","conf","p","red","prime","zero","toRed","one","two","n","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","j","nafW","repr","a","jpoint","b","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","len","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","index","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","_encode","compact","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","ceil","dbl","create","module","ctor","superCtor","super_","constructor","enumerable","writable","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","map","vec","_getEndoBasis","ntinv","s","redSqrt","redAdd","redSub","a0","b0","a1","a2","prevR","aprxSqrt","ushrn","floor","u","v","x1","y1","x2","y2","q","len1","sqr","negative","_endoSplit","v1","v2","c1","divRound","c2","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","split","ineg","fromJSON","pre","endoMul","toJSON","JSON","parse","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","t","yyyy8","d","f","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","base","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","options","defineCurve","defineProperty","get","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","reseed","addEnc","generate","temp","KeyPair","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","reason","getPrivate","sign","verify","signature","Signature","_importDER","recoveryParam","Position","place","getLength","buf","initial","octetLen","off","rmPadding","constructLength","octets","log","LN2","rlen","slen","toDER","backHalf","rand","hasOwnProperty","nh","keyPair","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","version","require$$2","require$$3","eddsa","_ec","_curve","getCurve","SigningKey","arrayify","p0","publicKey","digestBytes","splitSignature","hexZeroPad","otherKey","otherKeyPair","computePublicKey","_isSigningKey","compressed","signingKey","N","MasterSecret","toUtf8Bytes","HardenedBit","getUpperMask","bytes32","base58check","Base58","hexDataSlice","sha256","getWordlist","wordlist","wordlists","words","defaultPath","HDNode","parentFingerprint","chainCode","depth","mnemonicOrPath","compressedPublicKey","ripemd160","computeAddress","path","set","computeHmac","SupportedAlgorithm","IL","IR","ki","Ki","_addPoint","srcMnemonic","mnemonic","phrase","locale","fingerprint","components","shift","component","_derive","seedArray","password","entropyToMnemonic","mnemonicToEntropy","_fromSeed","salt","UnicodeNormalizationForm","pbkdf2","mnemonicToSeed","extendedKey","checkNormalize","offset","getWordIndex","normalize","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","checksum","join","getWord","Wallet","hasMnemonic","node","fromMnemonic","derivePath","isSigningKey","Provider","_mnemonic","_signingKey","signDigest","keccak256","serialize","joinSignature","hashMessage","_TypedDataEncoder","populated","progressCallback","encryptKeystore","extraEntropy","json","decryptJsonWallet","account","decryptJsonWalletSync","ethersUtils","createIdentity","innerHex","middleHex","createPrivateKey","wallet","stripHexPrefix","removeLeading0x","str","startsWith","addLeading0x","uint8ArrayToHex","hexToUnit8Array","compress","startsWith04","publicKeyConvert","decompress","startsWith02Or03","decompressed","toAddress","addressBuffer","pubToAddress","toBuffer","toChecksumAddress","stringify","compressedKey","ret","decryptWithPrivateKey","encrypted","twoStripped","encryptedBuffer","decrypt","decryptedBuffer","encryptWithPublicKey","pubString","encrypt","encryptedBuffers","publicKeyOfPrivateKey","privateToPublic","recoverPublicKey","sigOnly","recoveryNumber","pubKey","ecdsaRecover","recover","sigString","addressByPublicKey","sigObj","secp256k1_sign","recoveryId","recid","rawTx","txOptions","publicKeyByPrivateKey","privateKeyBuffer","Transaction","serializedTx","Coder","localName","dynamic","Writer","wordSize","_data","_dataLength","_padding","hexConcat","writer","_writeData","paddingOffset","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","_peekBytes","readBytes","AddressCoder","_throwError","writeValue","reader","readValue","AnonymousCoder","coder","defaultValue","decode","pack","coders","values","arrayValues","unique","argument","staticWriter","dynamicWriter","updateFuncs","forEach","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","func","appendWriter","unpack","baseReader","subReader","offsetReader","baseType","uniqueNames","reduce","accum","ArrayCoder","defaultChild","count","checkArgumentCount","BooleanCoder","DynamicBytesCoder","writeBytes","BytesCoder","FixedBytesCoder","NullCoder","NumberCoder","signed","maxUintValue","MaxUint256","bounds","mask","One","NegativeOne","Zero","StringCoder","toUtf8String","TupleCoder","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","populate","object","FormatTypes","sighash","minimal","full","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","_isParamType","format","indexed","comp","allowIndexed","fromString","isParamType","verifyType","param","originalParam","newNode","parent","state","allowType","allowParams","child","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","verifyState","isConstructorFragment","parens","outputs","output","isFunctionFragment","returns","checkForbidden","fragment","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","AbiCoder","_getCoder","_getWordSize","_getWriter","_getReader","defaultAbiCoder","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","wrapAccessError","property","wrap","Interface","fragments","abi","filter","getStatic","bucket","deploy","functions","events","errors","nameOrSignatureOrSighash","getSighash","matching","keys","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","method","topics","encodeTopic","id","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","args","topic","decodeEventLog","hexData","errorFragment","_isInterface","accessList","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","reject","makeError","contract","overrides","signer","override","check","resolvedAddress","resolved","interface","encodeFunctionData","ro","accessListify","intrinsic","roValue","leftovers","addContractWait","wait","bind","confirmations","receipt","logs","event","deepCopy","parsed","parseLog","eventSignature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","decodeFunctionResult","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","listener","once","done","item","listenerCount","argsCopy","setTimeout","apply","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","checkErrors","childPath","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","Contract","isSigner","uniqueFilters","filters","encodeFilterTopics","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","_deployedPromise","getCode","contractAddress","deployed","runningEvent","_runningEvents","eventName","_normalizeRunningEvent","emit","_wrappedEmits","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","on","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","listeners","removeAllListeners","getContractAddress","isInterface","isIndexed","ContractFactory","bytecode","bytecodeHex","encodeDeploy","unsignedTx","getDeployTransaction","getContract","compilerOutput","evm","getInterface","txDataByCompiled","factory","_toConsumableArray","calculateContractAddress","creatorAddress","generateAddress","SIGN_PREFIX","base64","string","fromCharCode","compressedString","hexString","vrs","util"],"sourceRoot":""}