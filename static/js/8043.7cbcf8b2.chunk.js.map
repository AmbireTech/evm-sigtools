{"version":3,"file":"static/js/8043.7cbcf8b2.chunk.js","mappings":"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","sources":["../node_modules/eccrypto/browser.js","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/eth-crypto/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/eth-crypto/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/create-identity.js","../node_modules/eth-crypto/dist/es/util.js","../node_modules/eth-crypto/dist/es/public-key.js","../node_modules/eth-crypto/dist/es/cipher.js","../node_modules/eth-crypto/dist/es/decrypt-with-private-key.js","../node_modules/eth-crypto/dist/es/encrypt-with-public-key.js","../node_modules/eth-crypto/dist/es/public-key-by-private-key.js","../node_modules/eth-crypto/dist/es/recover-public-key.js","../node_modules/eth-crypto/dist/es/recover.js","../node_modules/eth-crypto/dist/es/sign.js","../node_modules/eth-crypto/dist/es/sign-transaction.js","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/tx-data-by-compiled.js","../node_modules/eth-crypto/dist/es/calculate-contract-address.js","../node_modules/eth-crypto/dist/es/hash.js","../node_modules/eth-crypto/dist/es/hex.js","../node_modules/eth-crypto/dist/es/vrs.js","../node_modules/eth-crypto/dist/es/index.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.6.0\";\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.6.0\";\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.6.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        logger.checkNew(new.target, Wallet);\n\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const version = \"wallet/5.6.0\";\n","import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","export function removeLeading0x(str) {\n  if (str.startsWith('0x')) return str.substring(2);else return str;\n}\nexport function addLeading0x(str) {\n  if (!str.startsWith('0x')) return '0x' + str;else return str;\n}\nexport function uint8ArrayToHex(arr) {\n  return Buffer.from(arr).toString('hex');\n}\nexport function hexToUnit8Array(str) {\n  return new Uint8Array(Buffer.from(str, 'hex'));\n}","import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false)); // remove trailing 04\n\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\n\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher; // use compressed key because it's smaller\n\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'), // 16bit\n  Buffer.from(compressedKey, 'hex'), // 33bit\n  Buffer.from(cipher.mac, 'hex'), // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  }; // decompress publicKey\n\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","import { decrypt } from 'eccrypto';\nimport { parse } from './cipher';\nimport { removeLeading0x } from './util';\nexport default function decryptWithPrivateKey(privateKey, encrypted) {\n  encrypted = parse(encrypted); // remove trailing '0x' from privateKey\n\n  var twoStripped = removeLeading0x(privateKey);\n  var encryptedBuffer = {\n    iv: Buffer.from(encrypted.iv, 'hex'),\n    ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, 'hex'),\n    ciphertext: Buffer.from(encrypted.ciphertext, 'hex'),\n    mac: Buffer.from(encrypted.mac, 'hex')\n  };\n  return decrypt(Buffer.from(twoStripped, 'hex'), encryptedBuffer).then(function (decryptedBuffer) {\n    return decryptedBuffer.toString();\n  });\n}","import { encrypt } from 'eccrypto';\nimport { decompress } from './public-key';\nexport default function encryptWithPublicKey(publicKey, message, opts) {\n  // ensure its an uncompressed publicKey\n  publicKey = decompress(publicKey); // re-add the compression-flag\n\n  var pubString = '04' + publicKey;\n  return encrypt(Buffer.from(pubString, 'hex'), Buffer.from(message), opts ? opts : {}).then(function (encryptedBuffers) {\n    var encrypted = {\n      iv: encryptedBuffers.iv.toString('hex'),\n      ephemPublicKey: encryptedBuffers.ephemPublicKey.toString('hex'),\n      ciphertext: encryptedBuffers.ciphertext.toString('hex'),\n      mac: encryptedBuffers.mac.toString('hex')\n    };\n    return encrypted;\n  });\n}","import { privateToPublic, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\n/**\n * Generate publicKey from the privateKey.\n * This creates the uncompressed publicKey,\n * where 04 has stripped from left\n * @returns {string}\n */\n\nexport default function publicKeyOfPrivateKey(privateKey) {\n  privateKey = addLeading0x(privateKey);\n  var publicKeyBuffer = privateToPublic(toBuffer(privateKey));\n  return publicKeyBuffer.toString('hex');\n}","import { ecdsaRecover } from 'secp256k1';\nimport { removeLeading0x, hexToUnit8Array, uint8ArrayToHex } from './util';\n/**\n * returns the publicKey for the privateKey with which the messageHash was signed\n * @param  {string} signature\n * @param  {string} hash\n * @return {string} publicKey\n */\n\nexport default function recoverPublicKey(signature, hash) {\n  signature = removeLeading0x(signature); // split into v-value and sig\n\n  var sigOnly = signature.substring(0, signature.length - 2); // all but last 2 chars\n\n  var vValue = signature.slice(-2); // last 2 chars\n\n  var recoveryNumber = vValue === '1c' ? 1 : 0;\n  var pubKey = uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(sigOnly), recoveryNumber, hexToUnit8Array(removeLeading0x(hash)), false)); // remove trailing '04'\n\n  pubKey = pubKey.slice(2);\n  return pubKey;\n}","import recoverPublicKey from './recover-public-key';\nimport { toAddress as addressByPublicKey } from './public-key';\n/**\n * returns the adress with which the messageHash was signed\n * @param  {string} sigString\n * @param  {string} hash\n * @return {string} address\n */\n\nexport default function recover(sigString, hash) {\n  var pubkey = recoverPublicKey(sigString, hash);\n  var address = addressByPublicKey(pubkey);\n  return address;\n}","import { ecdsaSign as secp256k1_sign } from 'secp256k1';\nimport { addLeading0x, removeLeading0x } from './util';\n/**\n * signs the given message\n * we do not use sign from eth-lib because the pure secp256k1-version is 90% faster\n * @param  {string} privateKey\n * @param  {string} hash\n * @return {string} hexString\n */\n\nexport default function sign(privateKey, hash) {\n  hash = addLeading0x(hash);\n  if (hash.length !== 66) throw new Error('EthCrypto.sign(): Can only sign hashes, given: ' + hash);\n  var sigObj = secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(hash), 'hex')), new Uint8Array(Buffer.from(removeLeading0x(privateKey), 'hex')));\n  var recoveryId = sigObj.recid === 1 ? '1c' : '1b';\n  var newSignature = '0x' + Buffer.from(sigObj.signature).toString('hex') + recoveryId;\n  return newSignature;\n}","import { Transaction } from '@ethereumjs/tx';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport { toAddress as addressByPublicKey } from './public-key';\nexport default function signTransaction(rawTx, privateKey) {\n  var txOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // check if privateKey->address matches rawTx.from\n  var publicKey = publicKeyByPrivateKey(privateKey);\n  var address = addressByPublicKey(publicKey);\n  if (address != rawTx.from) throw new Error('EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey');\n  var privateKeyBuffer = Buffer.from(privateKey.replace(/^.{2}/g, ''), 'hex');\n  var tx = Transaction.fromTxData(rawTx, txOptions);\n  var signedTx = tx.sign(privateKeyBuffer);\n  var serializedTx = signedTx.serialize().toString('hex');\n  return serializedTx;\n}","export const version = \"abi/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        logger.checkNew(new.target, Contract);\n\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"contracts/5.6.0\";\n","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { ContractFactory } from 'ethers';\nexport default function txDataByCompiled(abi, bytecode, args) {\n  // solc returns a string which is often passed instead of the json\n  if (typeof abi === 'string') abi = JSON.parse(abi); // Construct a Contract Factory\n\n  var factory = new ContractFactory(abi, '0x' + bytecode);\n  var deployTransaction = factory.getDeployTransaction.apply(factory, _toConsumableArray(args));\n  return deployTransaction.data;\n}","import { generateAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\nexport default function calculateContractAddress(creatorAddress, nonce) {\n  var addressBuffer = generateAddress(toBuffer(addLeading0x(creatorAddress)), toBuffer(nonce));\n  var address = addressBuffer.toString('hex');\n  return toChecksumAddress(addLeading0x(address));\n}","import { utils as ethersUtils } from 'ethers';\nexport function keccak256(params) {\n  var types = [];\n  var values = [];\n\n  if (!Array.isArray(params)) {\n    types.push('string');\n    values.push(params);\n  } else {\n    params.forEach(function (p) {\n      types.push(p.type);\n      values.push(p.value);\n    });\n  }\n\n  return ethersUtils.solidityKeccak256(types, values);\n}\nexport var SIGN_PREFIX = '\\x19Ethereum Signed Message:\\n32';","/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex); // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n\n  var hex = '';\n\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","import { utils as ethersUtils } from 'ethers';\n/**\n * split signature-hex into parts\n * @param  {string} hexString\n * @return {{v: string, r: string, s: string}}\n */\n\nexport function fromString(hexString) {\n  var arr = ethersUtils.splitSignature(hexString);\n  return {\n    // convert \"v\" to hex\n    v: \"0x\".concat(arr.v.toString(16)),\n    r: arr.r,\n    s: arr.s\n  };\n}\n/**\n * merge signature-parts to one string\n * @param  {{v: string, r: string, s: string}} sig\n * @return {string} hexString\n */\n\nexport function toString(sig) {\n  return ethersUtils.joinSignature(sig);\n}","import createIdentity from './create-identity';\nimport * as publicKey from './public-key';\nimport decryptWithPrivateKey from './decrypt-with-private-key';\nimport encryptWithPublicKey from './encrypt-with-public-key';\nimport * as cipher from './cipher';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport recover from './recover';\nimport recoverPublicKey from './recover-public-key';\nimport sign from './sign';\nimport signTransaction from './sign-transaction';\nimport txDataByCompiled from './tx-data-by-compiled';\nimport calculateContractAddress from './calculate-contract-address';\nimport * as hash from './hash';\nimport * as hex from './hex';\nimport * as vrs from './vrs';\nimport * as util from './util';\nexport { createIdentity, publicKey, decryptWithPrivateKey, encryptWithPublicKey, cipher, publicKeyByPrivateKey, recover, recoverPublicKey, sign, signTransaction, txDataByCompiled, calculateContractAddress, hash, hex, vrs, util };\nexport default {\n  createIdentity: createIdentity,\n  publicKey: publicKey,\n  decryptWithPrivateKey: decryptWithPrivateKey,\n  encryptWithPublicKey: encryptWithPublicKey,\n  cipher: cipher,\n  publicKeyByPrivateKey: publicKeyByPrivateKey,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  sign: sign,\n  signTransaction: signTransaction,\n  txDataByCompiled: txDataByCompiled,\n  calculateContractAddress: calculateContractAddress,\n  hash: hash,\n  hex: hex,\n  vrs: vrs,\n  util: util\n};"],"names":["ec","EC","require","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isValidPrivateKey","privateKey","x","isBuffer","length","compare","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","result","createHash","update","digest","getAes","op","iv","key","data","importKey","name","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","getPublic","keyFromPrivate","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","exports","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","hash","encryptionKey","slice","dataToMac","hmac","createHmac","hmacSha256Sign","mac","sig","b1","b2","res","i","equalConstTime","macGood","logger","Logger","allowedTransactionKeys","forwardErrors","errors","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","Signer","checkAbstract","defineReadOnly","this","blockTag","_checkProvider","provider","getBalance","getAddress","getTransactionCount","transaction","resolveProperties","checkTransaction","tx","estimateGas","call","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getGasPrice","getFeeData","resolveName","indexOf","throwArgumentError","shallowCopy","all","toLowerCase","to","__awaiter","address","catch","error","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","type","feeData","throwError","UNSUPPORTED_OPERATION","operation","nonce","gasLimit","code","UNPREDICTABLE_GAS_LIMIT","getChainId","results","value","_isSigner","VoidSigner","checkNew","_fail","domain","types","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","hex","_hex","_isBigNumber","Object","freeze","toBigNumber","toBN","fromTwos","toTwos","substring","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","toString","BigInt","e","arguments","warn","UNEXPECTED_ARGUMENT","toHexString","match","toHex","String","anyValue","isBytes","hexlify","isHexString","fault","params","NUMERIC_FAULT","val","equal","l","r","utils","zero2","word","enc","Array","isArray","replace","push","parseInt","c","charCodeAt","hi","lo","encode","minAssert","minUtils","getNAF","num","w","bits","naf","Math","max","bitLength","fill","ws","k","clone","z","mod","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","prototype","undefined","parseBytes","bytes","intFromLE","BaseCurve","conf","p","red","prime","zero","toRed","one","two","n","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","j","nafW","repr","a","jpoint","b","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","len","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","index","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","_encode","compact","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","ceil","dbl","create","module","ctor","superCtor","super_","constructor","enumerable","writable","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","map","vec","_getEndoBasis","ntinv","s","redSqrt","redAdd","redSub","a0","b0","a1","a2","prevR","aprxSqrt","ushrn","floor","u","v","x1","y1","x2","y2","q","len1","sqr","negative","_endoSplit","v1","v2","c1","divRound","c2","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","split","ineg","fromJSON","pre","endoMul","toJSON","JSON","parse","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","t","yyyy8","d","f","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","base","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","options","defineCurve","defineProperty","get","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","reseed","addEnc","generate","temp","KeyPair","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","reason","getPrivate","sign","verify","signature","Signature","_importDER","recoveryParam","Position","place","getLength","buf","initial","octetLen","off","rmPadding","constructLength","octets","log","LN2","rlen","slen","toDER","backHalf","rand","hasOwnProperty","nh","keyPair","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","version","require$$2","require$$3","eddsa","_ec","_curve","getCurve","SigningKey","arrayify","p0","publicKey","digestBytes","splitSignature","hexZeroPad","otherKey","otherKeyPair","computePublicKey","_isSigningKey","compressed","signingKey","N","MasterSecret","toUtf8Bytes","HardenedBit","getUpperMask","bytes32","base58check","Base58","hexDataSlice","sha256","getWordlist","wordlist","wordlists","words","defaultPath","HDNode","parentFingerprint","chainCode","depth","mnemonicOrPath","compressedPublicKey","ripemd160","computeAddress","path","set","computeHmac","SupportedAlgorithm","IL","IR","ki","Ki","_addPoint","srcMnemonic","mnemonic","phrase","locale","fingerprint","components","shift","component","_derive","seedArray","password","entropyToMnemonic","mnemonicToEntropy","_fromSeed","salt","UnicodeNormalizationForm","NFKD","pbkdf2","mnemonicToSeed","extendedKey","decode","checkNormalize","offset","getWordIndex","normalize","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","checksum","join","getWord","Wallet","hasMnemonic","node","fromMnemonic","derivePath","isSigningKey","Provider","isProvider","_mnemonic","_signingKey","signDigest","keccak256","serialize","joinSignature","hashMessage","_TypedDataEncoder","resolveNames","populated","progressCallback","encryptKeystore","extraEntropy","json","decryptJsonWallet","account","decryptJsonWalletSync","MIN_ENTROPY_SIZE","ethersUtils","createIdentity","innerHex","middleHex","createPrivateKey","wallet","stripHexPrefix","removeLeading0x","str","startsWith","addLeading0x","uint8ArrayToHex","hexToUnit8Array","compress","startsWith04","publicKeyConvert","decompress","startsWith02Or03","decompressed","toAddress","addressBuffer","pubToAddress","toBuffer","toChecksumAddress","stringify","compressedKey","ret","decryptWithPrivateKey","encrypted","twoStripped","encryptedBuffer","decrypt","decryptedBuffer","encryptWithPublicKey","pubString","encrypt","encryptedBuffers","publicKeyOfPrivateKey","privateToPublic","recoverPublicKey","sigOnly","recoveryNumber","pubKey","ecdsaRecover","recover","sigString","addressByPublicKey","sigObj","secp256k1_sign","recoveryId","recid","rawTx","txOptions","publicKeyByPrivateKey","privateKeyBuffer","Transaction","fromTxData","Coder","localName","dynamic","Writer","wordSize","_data","_dataLength","_padding","hexConcat","writer","_writeData","paddingOffset","BUFFER_OVERRUN","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","_peekBytes","readBytes","AddressCoder","_throwError","writeValue","reader","readValue","AnonymousCoder","coder","defaultValue","pack","coders","values","arrayValues","unique","INVALID_ARGUMENT","argument","staticWriter","dynamicWriter","updateFuncs","forEach","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","func","appendWriter","unpack","baseReader","subReader","offsetReader","baseType","uniqueNames","reduce","accum","ArrayCoder","defaultChild","count","checkArgumentCount","BooleanCoder","DynamicBytesCoder","writeBytes","BytesCoder","FixedBytesCoder","NullCoder","NumberCoder","signed","maxUintValue","MaxUint256","mask","bounds","One","NegativeOne","Zero","StringCoder","toUtf8String","TupleCoder","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","populate","object","FormatTypes","sighash","minimal","full","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","_isParamType","format","indexed","comp","allowIndexed","fromString","isParamType","verifyType","param","originalParam","newNode","parent","state","allowType","allowParams","child","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","verifyState","isConstructorFragment","parens","outputs","output","isFunctionFragment","returns","checkForbidden","fragment","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","AbiCoder","_getCoder","_getWordSize","_getWriter","_getReader","defaultAbiCoder","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","wrapAccessError","property","wrap","Interface","fragments","abi","filter","getStatic","bucket","deploy","functions","events","nameOrSignatureOrSighash","getSighash","matching","keys","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","CALL_EXCEPTION","method","topics","encodeTopic","id","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","args","topic","decodeEventLog","hexData","errorFragment","_isInterface","accessList","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","reject","makeError","contract","overrides","signer","override","check","resolvedAddress","resolved","interface","encodeFunctionData","ro","accessListify","intrinsic","roValue","leftovers","addContractWait","wait","bind","confirmations","receipt","logs","event","deepCopy","parsed","parseLog","eventSignature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","decodeFunctionResult","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","listener","once","done","item","listenerCount","argsCopy","setTimeout","apply","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","checkErrors","childPath","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","Contract","isSigner","uniqueFilters","filters","encodeFilterTopics","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","_deployedPromise","getCode","contractAddress","deployed","runningEvent","_runningEvents","eventName","_normalizeRunningEvent","emit","_wrappedEmits","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","on","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","listeners","removeAllListeners","getContractAddress","isInterface","isIndexed","ContractFactory","bytecode","bytecodeHex","encodeDeploy","unsignedTx","getDeployTransaction","getContract","compilerOutput","MISSING_ARGUMENT","evm","getInterface","txDataByCompiled","factory","_toConsumableArray","calculateContractAddress","creatorAddress","generateAddress","SIGN_PREFIX","base64","string","fromCharCode","compressedString","hexString","vrs","util"],"sourceRoot":""}