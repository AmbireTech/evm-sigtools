{"version":3,"file":"static/js/5645.8b8767ff.chunk.js","mappings":"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","sources":["../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/src.ts/index.ts"],"sourcesContent":["export const version = \"providers/5.5.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: address,\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string): null | string {\n    try {\n        return toUtf8String(_parseBytes(result));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        try {\n            return _parseBytes(await this.provider.call(tx));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const transaction = {\n                    to: this.address,\n                    data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                };\n                const hexBytes = await this.provider.call(transaction);\n\n                // No address\n                if (hexBytes === \"0x\" || hexBytes === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(hexBytes);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ ];\n        try {\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n\n                if (match == null) { continue; }\n                switch (match[1]) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${ avatar.substring(7) }` }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: match[1], content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (match[1] === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (match[1] === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n                        let metadataUrl = _parseString(await this.provider.call(tx))\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (match[1] === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                        }\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n\n                        // Pull the image URL out\n                        if (!metadata || typeof(metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                            return null;\n                        }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                        linkage.push({ type: \"url\", content: metadata.image });\n\n                        return { linkage, url: metadata.image };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        logger.checkNew(new.target, Provider);\n\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    const filter = event.filter;\n                    filter.fromBlock = this._lastBlockNumber + 1;\n                    filter.toBlock = blockNumber;\n\n                    const runner = this.getLogs(filter).then((logs) => {\n                        if (logs.length === 0) { return; }\n                        logs.forEach((log: Log) => {\n                            this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                            this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                            this.emit(filter, log);\n                        });\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n                    runners.push(runner);\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"call\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params, result, error\n            });\n        }\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        try {\n            const address = await this._getResolver(name);\n            if (address == null) { return null; }\n            return new Resolver(this, address, name);\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    async _getResolver(name: string): Promise<string> {\n        // Get the resolver from the blockchain\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        const transaction = {\n            to: network.ensAddress,\n            data: (\"0x0178b8bf\" + namehash(name).substring(2))\n        };\n\n        try {\n            return this.formatter.callAddress(await this.call(transaction));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resovler\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddress = await this._getResolver(reverseName);\n        if (!resolverAddress) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        let bytes = arrayify(await this.call({\n            to: resolverAddress,\n            data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n        }));\n\n        // Strip off the dynamic string pointer (0x20)\n        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) { return null; }\n        bytes = bytes.slice(32);\n\n        // Not a length-prefixed string\n        if (bytes.length < 32) { return null; }\n\n        // Get the length of the string (from the length-prefix)\n        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n        bytes = bytes.slice(32);\n\n        // Length longer than available data\n        if (length > bytes.length) { return null; }\n\n        const name = toUtf8String(bytes.slice(0, length));\n\n        // Make sure the reverse record matches the foward record\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(reverseName);\n            if (!resolverAddress) { return null; }\n\n            resolver = new Resolver(this, resolverAddress, \"_\", address);\n\n        } else {\n            // ENS name; forward lookup\n            resolver = await this.getResolver(nameOrAddress);\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction checkError(method: string, error: any, params: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        logger.checkNew(new.target, JsonRpcSigner);\n\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        logger.checkNew(new.target, JsonRpcProvider);\n\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), params.position, params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue((<any>transaction)[key]);\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n"],"names":["version","logger","Logger","Formatter","constructor","checkNew","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","value","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","BigNumber","toNumber","toLowerCase","Error","strict","substring","isHexString","throwArgumentError","result","length","getAddress","callAddress","hexDataSlice","AddressZero","getContractAddress","hexValue","hexDataLength","error","hexZeroPad","_block","format","author","_difficulty","check","gas","isZero","input","chainId","networkId","parseInt","replace","parseTransaction","byzantium","Array","isArray","map","object","key","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","ForkEvent","isForkEvent","warn","getTime","Date","stall","duration","Promise","resolve","setTimeout","PollableEvents","Event","tag","listener","once","defineReadOnly","event","split","comps","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","encode","concat","sha256","matchers","RegExp","_parseString","toUtf8String","_parseBytes","offset","Resolver","provider","name","resolvedAddress","formatter","_fetchBytes","selector","parameters","tx","hexConcat","namehash","call","code","errors","CALL_EXCEPTION","_getAddress","coinType","hexBytes","coinInfo","String","throwError","UNSUPPORTED_OPERATION","operation","bytes","arrayify","match","words","bech32","unshift","HashZero","getAvatar","linkage","avatar","getText","i","content","url","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","fetchJson","image","JSON","stringify","getContentHash","ipfs","swarm","keyBytes","toUtf8Bytes","hexlify","defaultFormatter","nextPollId","BaseProvider","Provider","network","super","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","poll","then","NETWORK_ERROR","getNetwork","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_setFastBlockNumber","pollId","runners","pollingInterval","Math","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","log","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","reject","cancelFuncs","done","alreadyDone","func","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","eq","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","SERVER_ERROR","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","_getResolver","ensAddress","resolver","lookupAddress","reverseName","resolverAddress","nameOrAddress","NOT_IMPLEMENTED","_startEvent","e","_stopEvent","_addEventListener","args","stopped","eventTag","apply","listenerCount","listeners","off","removeAllListeners","found","errorGas","checkError","message","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","Signer","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","sender","hexlifyTransaction","signTransaction","signMessage","_legacySignMessage","_signTypedData","domain","types","populated","_TypedDataEncoder","resolveNames","getPayload","unlock","password","allowedTransactionKeys","JsonRpcProvider","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","defaultUrl","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","a","request","id","jsonrpc","action","deepCopy","cache","connection","response","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","StaticJsonRpcProvider","_super"],"sourceRoot":""}