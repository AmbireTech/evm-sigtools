{"version":3,"file":"static/js/1701.d3ef4889.chunk.js","mappings":"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","sources":["../node_modules/eccrypto/browser.js","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/eth-crypto/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/eth-crypto/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/eth-crypto/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/eth-crypto/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/eth-crypto/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/create-identity.js","../node_modules/eth-crypto/dist/es/util.js","../node_modules/eth-crypto/dist/es/public-key.js","../node_modules/eth-crypto/dist/es/cipher.js","../node_modules/eth-crypto/dist/es/decrypt-with-private-key.js","../node_modules/eth-crypto/dist/es/encrypt-with-public-key.js","../node_modules/eth-crypto/dist/es/public-key-by-private-key.js","../node_modules/eth-crypto/dist/es/recover-public-key.js","../node_modules/eth-crypto/dist/es/recover.js","../node_modules/eth-crypto/dist/es/sign.js","../node_modules/eth-crypto/dist/es/sign-transaction.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/eth-crypto/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/tx-data-by-compiled.js","../node_modules/eth-crypto/dist/es/calculate-contract-address.js","../node_modules/eth-crypto/dist/es/hash.js","../node_modules/eth-crypto/dist/es/hex.js","../node_modules/eth-crypto/dist/es/vrs.js","../node_modules/eth-crypto/dist/es/index.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.6.0\";\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","export const version = \"signing-key/5.6.0\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"hdnode/5.6.0\";\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        logger.checkNew(new.target, Wallet);\n\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const version = \"wallet/5.6.0\";\n","import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","export function removeLeading0x(str) {\n  if (str.startsWith('0x')) return str.substring(2);else return str;\n}\nexport function addLeading0x(str) {\n  if (!str.startsWith('0x')) return '0x' + str;else return str;\n}\nexport function uint8ArrayToHex(arr) {\n  return Buffer.from(arr).toString('hex');\n}\nexport function hexToUnit8Array(str) {\n  return new Uint8Array(Buffer.from(str, 'hex'));\n}","import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false)); // remove trailing 04\n\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\n\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher; // use compressed key because it's smaller\n\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'), // 16bit\n  Buffer.from(compressedKey, 'hex'), // 33bit\n  Buffer.from(cipher.mac, 'hex'), // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  }; // decompress publicKey\n\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","import { decrypt } from 'eccrypto';\nimport { parse } from './cipher';\nimport { removeLeading0x } from './util';\nexport default function decryptWithPrivateKey(privateKey, encrypted) {\n  encrypted = parse(encrypted); // remove trailing '0x' from privateKey\n\n  var twoStripped = removeLeading0x(privateKey);\n  var encryptedBuffer = {\n    iv: Buffer.from(encrypted.iv, 'hex'),\n    ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, 'hex'),\n    ciphertext: Buffer.from(encrypted.ciphertext, 'hex'),\n    mac: Buffer.from(encrypted.mac, 'hex')\n  };\n  return decrypt(Buffer.from(twoStripped, 'hex'), encryptedBuffer).then(function (decryptedBuffer) {\n    return decryptedBuffer.toString();\n  });\n}","import { encrypt } from 'eccrypto';\nimport { decompress } from './public-key';\nexport default function encryptWithPublicKey(publicKey, message, opts) {\n  // ensure its an uncompressed publicKey\n  publicKey = decompress(publicKey); // re-add the compression-flag\n\n  var pubString = '04' + publicKey;\n  return encrypt(Buffer.from(pubString, 'hex'), Buffer.from(message), opts ? opts : {}).then(function (encryptedBuffers) {\n    var encrypted = {\n      iv: encryptedBuffers.iv.toString('hex'),\n      ephemPublicKey: encryptedBuffers.ephemPublicKey.toString('hex'),\n      ciphertext: encryptedBuffers.ciphertext.toString('hex'),\n      mac: encryptedBuffers.mac.toString('hex')\n    };\n    return encrypted;\n  });\n}","import { privateToPublic, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\n/**\n * Generate publicKey from the privateKey.\n * This creates the uncompressed publicKey,\n * where 04 has stripped from left\n * @returns {string}\n */\n\nexport default function publicKeyOfPrivateKey(privateKey) {\n  privateKey = addLeading0x(privateKey);\n  var publicKeyBuffer = privateToPublic(toBuffer(privateKey));\n  return publicKeyBuffer.toString('hex');\n}","import { ecdsaRecover } from 'secp256k1';\nimport { removeLeading0x, hexToUnit8Array, uint8ArrayToHex } from './util';\n/**\n * returns the publicKey for the privateKey with which the messageHash was signed\n * @param  {string} signature\n * @param  {string} hash\n * @return {string} publicKey\n */\n\nexport default function recoverPublicKey(signature, hash) {\n  signature = removeLeading0x(signature); // split into v-value and sig\n\n  var sigOnly = signature.substring(0, signature.length - 2); // all but last 2 chars\n\n  var vValue = signature.slice(-2); // last 2 chars\n\n  var recoveryNumber = vValue === '1c' ? 1 : 0;\n  var pubKey = uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(sigOnly), recoveryNumber, hexToUnit8Array(removeLeading0x(hash)), false)); // remove trailing '04'\n\n  pubKey = pubKey.slice(2);\n  return pubKey;\n}","import recoverPublicKey from './recover-public-key';\nimport { toAddress as addressByPublicKey } from './public-key';\n/**\n * returns the adress with which the messageHash was signed\n * @param  {string} sigString\n * @param  {string} hash\n * @return {string} address\n */\n\nexport default function recover(sigString, hash) {\n  var pubkey = recoverPublicKey(sigString, hash);\n  var address = addressByPublicKey(pubkey);\n  return address;\n}","import { ecdsaSign as secp256k1_sign } from 'secp256k1';\nimport { addLeading0x, removeLeading0x } from './util';\n/**\n * signs the given message\n * we do not use sign from eth-lib because the pure secp256k1-version is 90% faster\n * @param  {string} privateKey\n * @param  {string} hash\n * @return {string} hexString\n */\n\nexport default function sign(privateKey, hash) {\n  hash = addLeading0x(hash);\n  if (hash.length !== 66) throw new Error('EthCrypto.sign(): Can only sign hashes, given: ' + hash);\n  var sigObj = secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(hash), 'hex')), new Uint8Array(Buffer.from(removeLeading0x(privateKey), 'hex')));\n  var recoveryId = sigObj.recid === 1 ? '1c' : '1b';\n  var newSignature = '0x' + Buffer.from(sigObj.signature).toString('hex') + recoveryId;\n  return newSignature;\n}","import { Transaction } from '@ethereumjs/tx';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport { toAddress as addressByPublicKey } from './public-key';\nexport default function signTransaction(rawTx, privateKey) {\n  var txOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // check if privateKey->address matches rawTx.from\n  var publicKey = publicKeyByPrivateKey(privateKey);\n  var address = addressByPublicKey(publicKey);\n  if (address != rawTx.from) throw new Error('EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey');\n  var privateKeyBuffer = Buffer.from(privateKey.replace(/^.{2}/g, ''), 'hex');\n  var tx = Transaction.fromTxData(rawTx, txOptions);\n  var signedTx = tx.sign(privateKeyBuffer);\n  var serializedTx = signedTx.serialize().toString('hex');\n  return serializedTx;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const version = \"abi/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        logger.checkNew(new.target, Contract);\n\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"contracts/5.6.0\";\n","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { ContractFactory } from 'ethers';\nexport default function txDataByCompiled(abi, bytecode, args) {\n  // solc returns a string which is often passed instead of the json\n  if (typeof abi === 'string') abi = JSON.parse(abi); // Construct a Contract Factory\n\n  var factory = new ContractFactory(abi, '0x' + bytecode);\n  var deployTransaction = factory.getDeployTransaction.apply(factory, _toConsumableArray(args));\n  return deployTransaction.data;\n}","import { generateAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\nexport default function calculateContractAddress(creatorAddress, nonce) {\n  var addressBuffer = generateAddress(toBuffer(addLeading0x(creatorAddress)), toBuffer(nonce));\n  var address = addressBuffer.toString('hex');\n  return toChecksumAddress(addLeading0x(address));\n}","import { utils as ethersUtils } from 'ethers';\nexport function keccak256(params) {\n  var types = [];\n  var values = [];\n\n  if (!Array.isArray(params)) {\n    types.push('string');\n    values.push(params);\n  } else {\n    params.forEach(function (p) {\n      types.push(p.type);\n      values.push(p.value);\n    });\n  }\n\n  return ethersUtils.solidityKeccak256(types, values);\n}\nexport var SIGN_PREFIX = '\\x19Ethereum Signed Message:\\n32';","/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex); // if base64:true, we use our own function because it results in a smaller output\n\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n\n  var hex = '';\n\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","import { utils as ethersUtils } from 'ethers';\n/**\n * split signature-hex into parts\n * @param  {string} hexString\n * @return {{v: string, r: string, s: string}}\n */\n\nexport function fromString(hexString) {\n  var arr = ethersUtils.splitSignature(hexString);\n  return {\n    // convert \"v\" to hex\n    v: \"0x\".concat(arr.v.toString(16)),\n    r: arr.r,\n    s: arr.s\n  };\n}\n/**\n * merge signature-parts to one string\n * @param  {{v: string, r: string, s: string}} sig\n * @return {string} hexString\n */\n\nexport function toString(sig) {\n  return ethersUtils.joinSignature(sig);\n}","import createIdentity from './create-identity';\nimport * as publicKey from './public-key';\nimport decryptWithPrivateKey from './decrypt-with-private-key';\nimport encryptWithPublicKey from './encrypt-with-public-key';\nimport * as cipher from './cipher';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport recover from './recover';\nimport recoverPublicKey from './recover-public-key';\nimport sign from './sign';\nimport signTransaction from './sign-transaction';\nimport txDataByCompiled from './tx-data-by-compiled';\nimport calculateContractAddress from './calculate-contract-address';\nimport * as hash from './hash';\nimport * as hex from './hex';\nimport * as vrs from './vrs';\nimport * as util from './util';\nexport { createIdentity, publicKey, decryptWithPrivateKey, encryptWithPublicKey, cipher, publicKeyByPrivateKey, recover, recoverPublicKey, sign, signTransaction, txDataByCompiled, calculateContractAddress, hash, hex, vrs, util };\nexport default {\n  createIdentity: createIdentity,\n  publicKey: publicKey,\n  decryptWithPrivateKey: decryptWithPrivateKey,\n  encryptWithPublicKey: encryptWithPublicKey,\n  cipher: cipher,\n  publicKeyByPrivateKey: publicKeyByPrivateKey,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  sign: sign,\n  signTransaction: signTransaction,\n  txDataByCompiled: txDataByCompiled,\n  calculateContractAddress: calculateContractAddress,\n  hash: hash,\n  hex: hex,\n  vrs: vrs,\n  util: util\n};"],"names":["ec","EC","require","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isValidPrivateKey","privateKey","x","isBuffer","length","compare","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","result","createHash","update","digest","getAes","op","iv","key","data","importKey","name","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","getPublic","keyFromPrivate","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","exports","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","hash","encryptionKey","slice","dataToMac","hmac","createHmac","hmacSha256Sign","mac","sig","b1","b2","res","i","equalConstTime","macGood","logger","Logger","allowedTransactionKeys","forwardErrors","errors","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","Signer","constructor","checkAbstract","defineReadOnly","this","getBalance","blockTag","_checkProvider","provider","getAddress","getTransactionCount","estimateGas","transaction","tx","resolveProperties","checkTransaction","call","sendTransaction","populateTransaction","signedTx","signTransaction","getChainId","getNetwork","chainId","getGasPrice","getFeeData","resolveName","indexOf","throwArgumentError","shallowCopy","all","toLowerCase","to","__awaiter","address","catch","error","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","type","feeData","throwError","UNSUPPORTED_OPERATION","operation","nonce","gasLimit","code","UNPREDICTABLE_GAS_LIMIT","results","isSigner","value","_isSigner","VoidSigner","checkNew","super","_fail","signMessage","_signTypedData","domain","types","connect","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","hex","_hex","_isBigNumber","Object","freeze","fromTwos","toBigNumber","toBN","toTwos","abs","substring","add","other","sub","div","isZero","throwFault","mul","mod","isNeg","umod","pow","and","isNegative","or","xor","mask","maskn","shl","shln","shr","shrn","eq","lt","lte","gt","gte","toNumber","toString","toBigInt","BigInt","e","arguments","warn","UNEXPECTED_ARGUMENT","toHexString","toJSON","match","toHex","String","anyValue","isBytes","hexlify","isHexString","isBigNumber","fault","params","NUMERIC_FAULT","val","equal","l","r","utils","zero2","word","enc","Array","isArray","replace","push","parseInt","c","charCodeAt","hi","lo","encode","minAssert","minUtils","getNAF","num","w","bits","naf","Math","max","bitLength","fill","ws","k","clone","z","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","prototype","undefined","parseBytes","bytes","intFromLE","BaseCurve","conf","p","red","prime","zero","toRed","one","two","n","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","j","nafW","repr","a","jpoint","b","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","len","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","index","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","_encode","compact","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","ceil","dbl","create","module","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","map","vec","_getEndoBasis","ntinv","s","redSqrt","redAdd","redSub","a0","b0","a1","a2","prevR","aprxSqrt","ushrn","floor","u","v","x1","y1","x2","y2","q","len1","sqr","negative","_endoSplit","v1","v2","c1","divRound","c2","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","split","ineg","fromJSON","pre","endoMul","JSON","parse","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","t","yyyy8","d","f","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","base","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","options","defineCurve","defineProperty","get","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","reseed","addEnc","generate","temp","KeyPair","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","reason","getPrivate","sign","verify","signature","Signature","_importDER","recoveryParam","Position","place","getLength","buf","initial","octetLen","off","rmPadding","constructLength","octets","log","LN2","rlen","slen","toDER","backHalf","rand","hasOwnProperty","nh","keyPair","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","version","require$$2","require$$3","eddsa","_ec","_curve","getCurve","SigningKey","arrayify","_addPoint","p0","publicKey","signDigest","digestBytes","splitSignature","hexZeroPad","computeSharedSecret","otherKey","otherKeyPair","compressed","signingKey","computePublicKey","isSigningKey","_isSigningKey","N","MasterSecret","toUtf8Bytes","HardenedBit","getUpperMask","bytes32","base58check","Base58","hexDataSlice","sha256","getWordlist","wordlist","wordlists","words","defaultPath","HDNode","parentFingerprint","chainCode","depth","mnemonicOrPath","compressedPublicKey","ripemd160","computeAddress","path","extendedKey","neuter","_derive","set","computeHmac","SupportedAlgorithm","IL","IR","ki","Ki","srcMnemonic","mnemonic","phrase","locale","fingerprint","derivePath","components","shift","component","_fromSeed","seedArray","fromMnemonic","password","entropyToMnemonic","mnemonicToEntropy","salt","UnicodeNormalizationForm","NFKD","pbkdf2","mnemonicToSeed","fromSeed","fromExtendedKey","decode","checkNormalize","offset","getWordIndex","normalize","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","checksum","join","getWord","Wallet","hasMnemonic","node","Provider","isProvider","_mnemonic","_signingKey","keccak256","serialize","joinSignature","hashMessage","populated","_TypedDataEncoder","resolveNames","encrypt","progressCallback","encryptKeystore","createRandom","extraEntropy","fromEncryptedJson","json","decryptJsonWallet","account","fromEncryptedJsonSync","decryptJsonWalletSync","MIN_ENTROPY_SIZE","ethersUtils","createIdentity","innerHex","middleHex","createPrivateKey","wallet","stripHexPrefix","removeLeading0x","str","startsWith","addLeading0x","uint8ArrayToHex","hexToUnit8Array","compress","startsWith04","publicKeyConvert","decompress","startsWith02Or03","decompressed","toAddress","addressBuffer","pubToAddress","toBuffer","toChecksumAddress","stringify","compressedKey","ret","decryptWithPrivateKey","encrypted","twoStripped","encryptedBuffer","decrypt","decryptedBuffer","encryptWithPublicKey","pubString","encryptedBuffers","publicKeyOfPrivateKey","privateToPublic","recoverPublicKey","sigOnly","recoveryNumber","pubKey","ecdsaRecover","recover","sigString","addressByPublicKey","sigObj","secp256k1_sign","recoveryId","recid","rawTx","txOptions","publicKeyByPrivateKey","privateKeyBuffer","Transaction","fromTxData","_arrayLikeToArray","arr2","_toConsumableArray","Symbol","iterator","o","minLen","test","TypeError","Coder","localName","dynamic","_throwError","Writer","wordSize","_data","_dataLength","_padding","hexConcat","_writeData","appendWriter","writer","writeBytes","paddingOffset","_getValue","BUFFER_OVERRUN","writeValue","writeUpdatableValue","Reader","coerceFunc","allowLoose","_offset","consumed","coerce","_coerceFunc","_peekBytes","loose","alignedLength","subReader","readBytes","readValue","AddressCoder","defaultValue","reader","AnonymousCoder","coder","pack","coders","values","arrayValues","unique","INVALID_ARGUMENT","argument","staticWriter","dynamicWriter","updateFuncs","forEach","dynamicOffset","updateFunc","baseOffset","func","unpack","baseReader","offsetReader","baseType","uniqueNames","reduce","accum","ArrayCoder","defaultChild","count","checkArgumentCount","BooleanCoder","DynamicBytesCoder","BytesCoder","FixedBytesCoder","NullCoder","NumberCoder","signed","maxUintValue","MaxUint256","bounds","One","NegativeOne","Zero","StringCoder","toUtf8String","TupleCoder","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","populate","object","FormatTypes","sighash","minimal","full","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","_isParamType","format","indexed","comp","allowIndexed","fromString","isParamType","verifyType","param","originalParam","newNode","parent","state","allowType","allowParams","child","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","verifyState","isConstructorFragment","parens","outputs","output","isFunctionFragment","returns","checkForbidden","fragment","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","AbiCoder","_getCoder","_getWordSize","_getReader","_getWriter","getDefaultValue","defaultAbiCoder","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","isIndexed","_isIndexed","BuiltinErrors","wrapAccessError","property","wrap","Interface","fragments","abi","filter","getStatic","bucket","deploy","functions","events","getAbiCoder","getSighash","id","getEventTopic","eventFragment","getFunction","nameOrSignatureOrSighash","matching","keys","getEvent","nameOrSignatureOrTopic","topichash","getError","_","_decodeParams","_abiCoder","_encodeParams","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","functionFragment","encodeFunctionData","decodeFunctionResult","errorArgs","errorName","errorSignature","selector","builtin","CALL_EXCEPTION","method","encodeFunctionResult","encodeFilterTopics","topics","encodeTopic","pop","encodeEventLog","dataTypes","dataValues","decodeEventLog","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","parseTransaction","args","parseLog","topic","parseError","hexData","errorFragment","isInterface","_isInterface","accessList","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","reject","makeError","contract","overrides","signer","override","check","resolved","resolvedAddress","interface","ro","accessListify","intrinsic","roValue","leftovers","addContractWait","wait","bind","confirmations","receipt","logs","event","deepCopy","parsed","eventSignature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","addListener","listener","once","done","item","removeAllListeners","listeners","listenerCount","run","argsCopy","setTimeout","apply","prepareEvent","getEmit","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","checkErrors","childPath","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","Contract","uniqueFilters","filters","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","getContractAddress","getInterface","deployed","_deployedPromise","getCode","contractAddress","fallback","attach","_normalizeRunningEvent","runningEvent","_runningEvents","_getRunningEvent","eventName","_checkRunningEvents","emit","_wrappedEmits","_wrapEvent","_addEventListener","wrappedEmit","on","queryFilter","fromBlockOrBlockhash","toBlock","fromBlock","getLogs","ContractFactory","bytecode","bytecodeHex","getDeployTransaction","unsignedTx","getContract","fromSolidity","compilerOutput","MISSING_ARGUMENT","evm","txDataByCompiled","factory","calculateContractAddress","creatorAddress","generateAddress","SIGN_PREFIX","base64","string","fromCharCode","compressedString","hexString","vrs","util"],"sourceRoot":""}